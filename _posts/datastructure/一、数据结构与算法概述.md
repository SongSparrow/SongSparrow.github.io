#  一、数据结构与算法概述

## 1. 什么是数据结构

用来存储和组织数据的集合

## 2. 数据结构的分类

1. 逻辑结构
2. 物理结构

### 2.1 逻辑结构

1. 集合结构：元素之间没有特定关系
2. 线性结构：结构中的元素是一对一的关系
3. 树形结构：结构中的元素是一对多的关系
4. 图形结构：结构中的元素是多对多的关系

### 2.2 物理结构

1. 顺序结构：便于查找，不便于插入
2. 链式结构：便于插入，不便于查找



# 二、算法分析

## 1. 算法的时间复杂度分析

把核心操作次数和输入规模联系起来

### 1.1 函数渐近分析

结论：

1. 算法函数中的常数往往可以忽略
2. 算法函数中的最高次幂的常数因子可以忽略
3. 算法函数中的最高次幂越小，算法效率效率越高

### 1.2 算法的时间复杂度

#### 1.2.1 O记法

规则：

1. 使用1代替所有的常数运算
2. 在修改的运行次数中只保留高阶项
3. 如果高阶项的系数不为1，则去除这个与高阶项相乘的常数

#### 1.2.2 O阶

线性阶：单层循环

平方阶：嵌套循环

立方阶：三层浅套循环

对数阶：

指数阶：

常数阶：

#### 1.2.3 函数调用复杂度分析

计算一个函数的复杂度时也要算上这个函数调用的函数的复杂度

#### 1.2.4 最坏情况

最好情况

最坏情况：要保证程序，在最坏的情况下可以正常运行

平均情况：更具有参考价值



### 1.3 算法的空间复杂度



#### 1.3.1 java基本数据类型的内存占用

计算机访问内存的方式是每次访问一个字节，即访问的单位是字节

| 数据类型 | 占用字节数 |
| :------: | :--------: |
|   byte   |     1      |
|  short   |     2      |
|   int    |     4      |
|   long   |     8      |
|  float   |     4      |
|  double  |     8      |
|   char   |     1      |
| boolean  |     2      |

- 一个引用占用8个字节

- 一个对象，处了对象内部存储的数据，每个对象还有用来保存对象头信息的额外16个字节

- 一般内存的使用，如果字节数目不是8的倍数，会被空内存填充至8的倍数

- 一个数组，对象头16字节，数组长度4个字节，用来填充的4个字节，保存的数据所占用的字节

#### 1.3.2 算法的空间复杂度

算法的空间复杂度估算与表示与时间复杂度的原则一致

在如今的计算机中，一般不太需要过多的考虑空间的复杂度，因为内存一般都够用，但是在一些嵌入式设备、传感器设备中，则需要仔细考虑，因为这类设备的内存往往非常有限



# 三、排序算法

## 1. 冒泡排序

### 原理

比较相邻的元素，如果满足条件，就换二者的位置



### 代码

```c++
cout<<array<<endl;
for(int i=0; i<n; i++){
    for(int j=i+1; j<n; j++){
        if(array[i]>array[j]){
            int tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
        }
    }
}
cout<<array<<endl;
```



### 复杂度分析

核心操作是比较和元素交换

最坏情况比较次数：$(N-1)+(N-2)+...+0=(N-1)*N/2$

最坏情况交换次数：$(N-1)+(N-2)+...+0=(N-1)*N/2$

时间复杂度为：$[(N-1)*N/2]*2=N^2-N$

O表示法为$O(N^2)$



## 2. 选择排序

### 原理

在每次遍历过程中，都假定第一个元素为最小值，然后将元素与其他索引处的值比较，如果其它索引处的值比第一个值小，就认为它是最小值，然后与剩下的元素比较，这样最后可以找到真正最小值的索引

### 代码

```c++
for(int i=0; i<n; i++){
    int k=i;
    for(int j=i+1; j<n; j++){
        if(array[k]>array[j]){
            k=j;
        }
    }
    if(array[k] != array[i]){
        int tmp = array[k];
        array[k] = array[i];
        array[i] = arraytmp;
    }
}
```

### 复杂度分析

核心操作是比较与排序

最坏情况比较次数：$(N-1)+1+(N-2)+1+...+1=(N-1)*N/2+N=(N+1)*N/2$

最坏情况交换次数：$N$

最坏情况的复杂度为：$N+(N+1)*N/2=(N+3)*N/2$

O表示法记为$O(N^2)$



## 3. 插入排序

### 原理

将数组分为已排序部分和未排序部分

取出未排序部分的第一个值，将它插入到已排序的部分

插入方式是倒序遍历已排序的部分，直到出现小于该元素的元素的元素，在将未排序元素插入到找到的元素后面

### 代码

```c++
for(int b=1; b<n; b++){
    for(int i=b-1; i=>0; i--){
        if(array[b]<array[i]){
            int tmp = array[b];
            array[b] = array[i];
            array[i] = tmp;
        }else{
            break;
        }
    }    
}
```

### 复杂度分析

核心操作时元素之间的比较与交换

最坏情况的比较次数：$1+2+...+(N-1)=(N-1)*N/2$

最坏情况的交换次数：$1+2+...+(N-1)=(N-1)*N/2$

最坏情况的时间复杂度：$(N-1)*N$

最坏情况的O表示法为$O(N^2)$

## 4. 希尔排序(缩小增量排序)

### 原理

希尔排序是插入排序的一种，是对基础插入排序的改良

插入排序的插入过程效率非常低，希望对其进行改良

操作步骤：

1. 选定一个增长量h，对数据进行分组

2. 对每一组数据进行插入排序

3. 减小h，重复步骤二，直到h为1

操作原则：

1. h的选取原则

   ```c++
   int h=1;
   while(h<n/2){
       h=2*h+1
   }
   ```

2. h减小原则

   ```c++
   h = h/2
   ```

### 代码

```c++
int h=1;
while(h<n/2){
    h=2*h+1
}

while(h>=1){
    for(int i=0; i<n; i+=h){
        for(int j=i+h; j<n; j+=h){
            if(array[j]<array[j-h]){
                int tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
            }else{
                break;
            }
        }
    }
    h=h/2;
}
```

### 复杂度分析

事前估算法过于复杂，这里采用事后估算法进行分析

对于希尔排序的复杂度的分析，目前还没有定论，但是普遍认为其复杂度是介于$O(n\log_2n)$~$O(n^2)$，平均复杂度大致是$O(n^{\frac{3}{2}})$



## 5. 归并排序

### 原理

分治策略的典型应用之一

操作步骤：

1. 尽可能进一组数据分为元素数量相等的两个子组，并对每一个子组进行拆分，直到子组元素数量为1

2. 将相邻的两个子组合并进行合成，得到一个有序的大组

3. 不短重复步骤2直到只有一个大组

### 代码

```c++
void merge(vector<int> &a1,size_t left, size_t mid,size_t right){
    size_t n1 = a1.length();
    int i = 0;
    int j = mid;
    vector merge;
    while(i<mid && j<n1){
        if(a1.at(i) < a1.at(j)){
            merge.push_back(a1.at(i++));
        }else{
            merge.push_back(a1.at(j++));
        }
    }
    while(i<mid){
        merge.push_back(a1.at(i++))
    }
    while(j<n1){
        mergw.push_back(a1.at(j++))
    }
    a1 = merge;
}

void merge_sort(vector<int> &a1,size_t left, size_t right){
    if(left >= right) return;
    size_t mid = left + (right - left)/2;
    merge_sort(a1,left,middle);
    merge_sort(a1,middle+1,right);
    merge(a1,left,mid,right)
}
```

### 复杂度分析

如果一个数组有n个元素，那么它将每次除以二找到最小的子数组，共拆$\log_2 n$次，记为m次，第k次，就已经拆分出了$2^k$个数组，每个数组的长度为$2^{m-k}$，归并最多需要$2^{m-k}$次比较，所以每一次拆分需要的比较次数为$2^k*2^{m-k}=2^m$次比较，也就是整个过程需要$m*2^m$次比较，将$m=\log_2 n$代入得$n*\log_2n$，使用O表示为$O(n*\log n)$

### 缺点

需要申请额外内存空间，而且采用的是递归调用，增加了空间复杂度

## 6. 快速排序

### 原理

快速排序是对冒泡排序的一种改进，也采用了分治算法



设定一个分界值，通过该分界值将数组分成两部分

将大于或等于分界值的元素放到分界值右边，小于分界值的元素放到分界值的左边

然后对分界值两边的数组进行同样的操作，直到只有一个元素



用两个指针分别指向数组的头部和尾部

先从尾部向头部开始搜索比分界值小的元素，直到搜索到

再从头部向尾部开始搜索比分界值大的元素，直到搜索到

交换两个元素的位置

重复此过程直到左边指针的值等于右边指针的值

### 代码

```c++
void quick_sort(vector<int> &a, size_t left, size_t right){
    if(left >= right) return;
    size_t partion = partion(a,left,right);
    quick_sort(a,left,partion);
    quick_sort(a,partion+1,right);
}

size_t partion(vector<int> &a,size_t left, size_t right){
    while(left<=right){
        while(a.at(left)<key){
            left++;
            if(right<=left)break;
        }
        while(a.at(right)>key){
            right--;
            if(right<=left)break;
        }
        int tmp = array.at(left);
        array.at(left) = array.at(right);
        array.at(right) = tmp;        
    }
}
```

### 快速排序与归并排序的区别

归并排序要有归并操作，快速排序中所有子数组有序时，整个数组也就是有序的了

归并排序的两个子数组是等长的，快速排序中的两个子数组长度不固定

### 复杂性分析

快速排序的一次切分从两头开始交替搜索，直到left和right指针重合，因此一次切分算法的时间复杂度为$O(n)$，但整个快速排序的时间复杂度和切分的次数有关

最优情况：每次选择的基准值恰好将当前的序列两等分，此时要进行$\log_2n$次切分，时间复杂度为$O(n*\log n)$

最坏情况：每次选择的基准值都是当前数组的最大或者最小值，将当前序列的所有元素全部分进同一个子数组，此时要进行n此拆分，时间复杂度为$O(n^2)$

平均情况：可以使用数学归纳法证明，快速排序的平均情况的时间复杂度为$O(n*\log n)$



## 7. 排序算法的稳定性

### 稳定性定义

数组array中有若干元素，其中A和B相等，若A在B前面，经过某种排序算法排序之后A仍然在B的前面，可以说该排序算法是稳定的

### 稳定性的意义

如果一组数据只进行一次排序，稳定性一般是没有意义的

如果一个数组需要多次排序，按不同的属性排序，使用稳定的排序算法时，就可以保证之前的排序的有效性

### 常见排序算法的稳定性

| 排序算法 | 是否稳定 |
| -------- | -------- |
| 冒泡排序 | 是       |
| 选择排序 | 否       |
| 插入排序 | 是       |
| 希尔排序 | 否       |
| 归并排序 | 是       |
| 快速排序 | 否       |

补充

## 8. 桶排序

### 核心思想

将要排序的数据分到几个有序的桶里，每个桶的数据再进行单独排序，桶内排完序之后，在将桶里的数据依次取出，组成的的序列就是有序的了

也就是说桶排序是将待排序集合中处于同一个值域的元素存入同一个桶中，也就是根据元素值的特性将集合拆分为多个区域，每个区域作为一个桶，从至于上看是有序状态的，对每个桶中的元素进行排序，则桶中元素构成的序列是已排序的。

### 关键环节

元素值域的划分

元素从待排序序列中映射到桶中的过程

### 实现

1. 找出序列中的最大值和最小值

2. 计算桶的个数，[min,max]/size+1

3. 按照顺序创建桶

4. 将待排序的集合依次添加到桶中，index=(i-min)/size;

5. 对每个桶中的元素进行排序

### 时间复杂度

一定程度上取决于桶内采用的排序算法，介于O(n)~O(n*logn)

### 空间复杂度

O(N+M)，M是桶所占用的空间。桶排序是采用了空间换时间的策略

### 稳定性

桶排序是否稳定取决于每个桶内采用的排序算法，如果所有桶内采用的排序算法都是稳定的，那么桶排序就是稳定的，否则就不是稳定的。

### 应用场景

如果有非常大的数据量，可以将数据分成几若干文件，在对文件中的数据进行排序，然后按序读取文件



## 9. 计数排序

### 原理

计数排序是一种特殊的桶排序

遍历序列，统计每个元素出现的次数，将结果放到一个有序的结果集中，统计完毕之后，依次输出对应数目的元素，形成一个有序的序列

无法保证稳定性



# 四、 线性表

## 1. 顺序表

内部方法：

1. 获取元素

2. 追加元素

3. 插入元素

4. 删除元素

5. 清空列表

6. 遍历

7. 扩容
8. 当前元素个数
9. 列表是否为空



时间复杂度：

get(i)，不管要返回那个位置的元素，都是通过索引直接获取，所以是$O(1)$

insert(i)，为了插入一个元素，必须移动数组里的其他元素，平均来讲插入一个元素需要移动$\frac{n}{2}$个其他元素，所以是$O(n)$，remove(i)同理。但是有的时候，为了插入一个元素需要进行扩容，申请内存的操作是很耗时的



## 2. 链表

内部方法：

同顺序表



时间复杂度分析：

get(i)，要获取一个元素，就必须从头开始找，直到发现该元素，平均来讲，要找到一个元素，需要遍历$\frac{n}{2}$次，进行$\frac{n}{2}$次比较，所以其时间复杂度为$O(n)$



insert(i)，要往列表中插入一个元素，只需要三步，与插入位置无关，但是要先从头开始查找要插入元素对应的位置，同get操作，所以其时间复杂度为$O(n)$，remove(i)，同理

列表中申请内存的操作是在创建新的节点时创建的，申请同样大小的内存空间，一次性申请要比分批申请更效率一些。为了避免使用链表时频繁地申请和回收内存，可以重写new和delete运算符，使用空间表，来缓解这个问题。对于java来说，只要注意避免删除元素时让垃圾处理器回收删除的节点即可，在进行new时，可以使用这个废弃的元素，对其进行重新赋值



反转：

链表结构的反转过程可以用递归方式实现，也可以用循环的方式实现，但是尽量用循环结构，因为递归不安全，数据量大时容易造成栈溢出

```c++
void reverse(){
    current = head;
    Node<int> *tmp1 = head->next;
    Node<int> *tmp2 = tmp1->next;
    tmp1->next = nullptr;
    while(tmp2->next != nullptr){
        current = tmp1;
        tmp1 = tmp2;
        tmp2 = tmp2->next;
        tmp1->next = current;
    }
    head->next = tmp1;
}
```



## 3. 快慢指针

快慢指针指的是定义两个指针，移动速度一快一慢，以此制造想要的差值，这个差值可以帮助找到链表中对应的节点，一般情况下，快指针的移动速度是慢指针的两倍

### 3.1 中间值问题

如果快指针的移动速度是慢指针的两倍，快慢指针同时开始从头节点往后遍历，当快指针遍历到链表尾部时，慢指针则恰好停留在中间值处

```c++
Node<T>& get_mid(){
    fast = head;
    slow = head;
    while(fast != nullptr && fast->next != nullptr){
        fast = fast.next->next;
        slow = slow.next
    }
    return slow;
}
```



### 3.2  单向链表是否有环问题

如果程链表中没有环结构，那么快慢指针不会相遇，如果有环结构，快慢指针则会相遇

```c++
bool has_circle(){
    fast = head;
    slow = head;
    while(fast != nullptr && fast->next != nullptr){
        fast = fast->next.next;
        slow = slow.next;
        if(fast==slow) return true;
    }
    return false;
}
```



### 3.3  有环列表的入口

数论的知识可以证明，在一个有环的链表中，使用快慢指针探测出来环存在时，再使用一个新的指针指向链表的头节点，步长与慢指针一样，接着进行遍历，慢指针与新指针相遇的地方就是环的入口

```c++
Node<T> get_entrance(){
    fast = head;
    slow = head;
    Node<T> *tmp = nullptr;
    while(fast != nullptr && fast->next != nullptr){
        fast =fast->next->next;
        slow = slow->next;
        if(fast==slow){
            tmp = head;
            continue; // 当快慢指针相遇时，新指针指向头节点即可，不用走下一步
        }
        if(tmp != nullptr){
            tmp = tmp.next;
            if(tmp == slow) break;
        }
    }
    return tmp;
}
```

## 4. 循环链表

尾结点的next指针指向头节点



## 5. 约瑟夫问题

```c++
int Joseph(int n,int m){
    int i, s=0;
    for(i=2; i<=n; i++){
        s=(s+m)%i;
    }
    return (s+1);
}
```



## 6. 栈

先进后出

内部方法：pop()、push()、is_empty()、size()

应用：括号匹配、逆波兰表达式等

索引：index = (index+1)%size;



## 7. 队列

先进先出

内部方法：push()、top()、is_empty()、size()

应用：



# 五、符号表

符号表的主要目的就是将一个键和一个值关联起来，符号表能够存储的数据是一个键和一个值共同组成的键值对，可以根据键查找对应的值，符号表中键应该是唯一的。

符号表的应用举例：字典、图书索引、网络搜索

## 1. 符号表的实现

节点是由键和值组成、组织方式可以使用线性表、树形结构

## 2. 有序符号表

插入时按键值进行组织，使得整个符号表有序



# 六、二叉树

## 1. 树的基本定义

树是由n(n>=1)个有限节点组成的一个具有层次关系的集合。

树的特点：

1. 每个节点有零个或多个子节点
2. 没有父节点的节点是根节点
3. 每一个非根节点都只有一个父节点
4. 每个节点及其后代节点都可以看作是一棵树，成为当前节点的父节点的一个子树

## 2. 树的相关术语

1. 结点的度：一个节点含有子树的个数成为该节点的度

2. 叶节点：度为0的节点

3. 分支节点：度不为0 的节点

4. 节点的层次：根节点的层次为1，后继层的层次为2，依此类推

5. 节点的层序编号：将一颗树的所有节点按从上到下，从左到右的顺序进行编号

6. 树的度：书中所有节点的度的最大值

7. 树的高度：树中结点的最大层次

8. 森林：m(m>0)棵不相交的树的集合

9. 子节点：一个结点的直接后继节点称为该节点的子节点

10. 父节点：一个结点的直接前驱节点称为该节点的父节点

11. 兄弟节点：同一父节点的所有子节点之间互相称为兄弟节点



## 3. 二叉树的定义

1. 二叉树：度不超过2的树

2. 满二叉树：每一层的节点数都达到最大值的二叉树

3. 完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的叶节点都集中在该层最左边的若干位置的二叉树。



## 4. 二叉检索树的创建

### 4.1 内部成员与内部方法

成员：

在节点中：left、right、key、value

树中的成员：root、n

树中的方法：append()、delete()、search()、size()

### 4.2 查找

1. 如果还没有节点返回nullptr

2. 如果大于当前节点的key，继续查找当前节点的右子节点

3. 如果小于当前节点的key，继续查找当前节点的左子节点

4. 如果等于当前节点的key，返回当前节点

### 4.3 插入

先找到对应的位置，再插入

1. 如果当前树还没有节点，就让新节点作为树的根节点

2. 如果新节点的key大于当前节点的key，就继续寻找当前节点的右子节点

3. 如果新节点的key小于当前节点的key，就继续寻找当前节点的左子节点

4. 如果新节点的key等于当前节点的key，就用新节点的值替换当前节点的值
5. 如果新节点的key小于当前节点的key，当前节点的左子树指针为空，那么新节点就插入到这里
6. 如果新节点的key小于当前节点的key，当前节点的右子树指针为空，那么新节点就插入到这里

### 4.4 删除

先找到要删除的key，再删除

1. 如果当前树没有节点，就停止

2. 如果大于当前节点的key，如果right不是nullptr，就查找右子树，否则停止

3. 如果小于当前节点的key，如果left不是nullptr，就查找左子树，否则停止

4. 如果等于当前节点的key，就进入下一阶段

5. 如果要删除的节点是叶节点，则直接删除

6. 如果要删除的节点仅有右子树，那么父指针指向右子树，删除该节点

7. 如果要删除的节点仅有左子树，那么父指针指向左子树，删除该节点

8. 如果要删除的节点有左子树和右子树，那么找到右子树中的最小key的节点；该节点的父指针赋值为该节点的right，该节点的left赋值为要删除节点的left，该节点的right赋值为要删除节点的right，要删除节点的父指针指向该节点，删除要删除的节点

## 5. 二叉树的遍历

前序遍历

中序遍历

后序遍历

```

```

## 6. 二叉树的层序遍历

1. 广度遍历的思想
2. 创建一个节点队列

2. 使用循环队列从队列中弹出一个结点：
   1. 获取当前节点的key
   2. 如果当前节点的左子节点不为空，那么将它放入队列
   3. 如果当前节点的右子节点不为空，那么将它放入队列

```

```

## 7. 二叉树的最大深度问题

1. 如果根节点为空，则最大深度为0

2. 计算左子树的最大深度；

3. 计算右子树的最大深度

4. 当前数的最大深度 = 左子树的最大深度和右子树的最大深度中的较大者为+1



## 8. 二叉树的折纸问题

以下折痕为根节点，建立二叉树，每次对折，所有的叶子节点都生成两个子节点，即左子节点下折痕，右子节点上折痕；这些这很在纸上的展现情况是对这很二叉树的中序遍历



# 七、堆

## 1.堆的定义

1. 堆是完全二叉树

2. 用数组实现，索引0处空着，索引1处放根节点，让后依次放入每一层的节点，这样，对于任意一个节点，其索引为k，则其父节点为[k/2]，子节点为[2\*k] 和 [2*k+1]

3. 每个节点都大于其两个子节点

## 2. 堆的实现

### 上浮算法

如果往堆中插入新的元素，只需要不断比较新节点和其父节点的大小，如果比父节点大，就与父节点交换位置，直到不比父节点大

```c++
void swim(int N){
    while(N>1){
        if(array[N] > array[N/2]){
            swap(array,N,N/2);
            N = N/2;
        }else break;
    }
}
```



### 下沉算法

比较当前节点的两个子节点，取较大者与新节点比较，如果新节点小于该节点，就交换二者的位置，依次循环，直到新节点大于两个子节点

```c++
void sink(int N){
    while(N*2<=size){
        left = N*2;
        right = left+1;
        if(right<=size){
            if(array[left]>array[right]){
                larger = left;
            }else{
                larger = right;
            }
        }else{
            larger = left;
        }
        if(array[N]<larger){
            swap(array,N,larger);
            N = larger;
        }else
            break;
    }    
}
```



### 元素的删除

将最后一个元素与要删除的元素交换位置，使用下沉算法使最后一个元素处于合适的位置，size减1即可。



## 3. 堆排序

详见3.8



# 八、优先队列

使用堆这种数据结构实现，可分为最大优先队列和最小优先队列

最大优先队列每次去除最大值

最小优先队列每次取出最小值



## 1. 最大/小优先队列

最大值放在索引1处

父节点总是比子节点的值大

```c++
void push(T& e){
    if(N<size){
        array[++N] = e;
 		swim(N);	
    }
}
T pop(){
    T max = array[1];
    swap(1,N);
    sink(1);
}
void swim(int i){
    while(i>0){
        if(array[i]>array[i/2]){
        	swap(i,i/2);    
		}
        i /= 2;
    }
}
void sink(int i){
    while(i*2<N){
        int left = i*2;
        int right;
        if((left+1)<=N){
            right = left+1;
            if(array[left]>array[right]){
                if(array[left]>array[i]){
                    swap(left,i);
                }
            }else{
                if(array[right]>array[i]){
                    swap(right,i);
                }
            }
        }else{
            if(array[left]>array[i]){
            	     swap(left,i);
            }
        }
        i *= 2;
    }
}
```



## 2. 索引优先队列

通过添加辅助数组pq和其逆序qp来为优先队列中的元素添加索引

```c++
void init(int size){
    this->size = size;
    N=0;
    array = new T[size+1];
    int pq = new int[size+1];
    int qp = new int[size+1];
    for(int i=0; i<=size; i++){
        qp[i] = -1;
    }
}

bool contain(int i){
    if(i<0 || i>size) return false;
    return qp[i] != -1;
}

void insert(int i, T& e){
    if(i<0 || i>size) return;
    if(contain(i)){
        array[i] = e;
        
        
        
    }else{
        array[i] = e;
        swim(i);
       	
    }
}

T& pop(){
    
}

void swim(int i){
    
}

void sink(int i){
    
}
```



# 九、平衡树

## 1.1 2-3查找树

### 定义

2-节点：

含有一个键及其对应的值和两条链，左连接指向2-3树中的键都小于该节点，右链指向2-3树中的键都大于该节点。

3-节点：

含有两个键及其对应值和三条链，左连接指向2-3树中的键都小于该节点，中链指向的键都位于该节点的两个键之间，右链指向2-3树中的键都大于该节点

### 查找

要判断一个键是否在书中，首先将它与树的根节点进行比较，如果它和任意其中任意一个相等，就是查找命中；否则就根据查找结果，找到指向相应区间的链接，并在其指向的子树中继续递归地查找。如果这是一个空连接，则查找未命中。

### 插入

#### 向2-节点中插入新键

首先进行查找，将要插入的键值对挂到未找到的节点上。2-3查找树之所以可以在最差的情况下保证查找效率，是因为它可以保持属的平衡性。如果查到的节点是一个2-节点，那么就将要插入的节点与该节点合并，使其成为一个3-节点即可。

#### 向一个只含有3-节点的树中插入新键

是要插入的节点暂时成为一个4-节点，它包含三个键，四条链接。然后将4-节点的中间元素提升，左边的键作为左子节点，右边的键作为右子节点。

#### 向一个父节点为2-节点的3-节点中插入新键

将该节点插入3-节点中使其成为一个临时的4-节点，然后将中各4-节点的中间元素提升到父节点中。使其成为一个3-节点，左右节点分别挂在这个3-节点的合适位置

#### 向一个父节点为-节点的3-节点中插入新键

将新建插入到中各3-节点后，其父节点变成了一个临时的4-节点，然后将这个4-节点进行拆分，直到遇到一个2-节点或者到根节点，也就是直到不再需要拆分为止

#### 分解根节点

当插入节点与根节点的路径上全部为3-节点时，最终根节点会变成一个临时的4-节点，此时再将根节点拆分成2个2-节点，树的高度加一

### 2-3树的性质

一棵完全平衡的2-3查找树具有如下性质：

1. 任意空连接到根节点的路径长度是相等的

2. 4-节点变换为3-节点时，树的高度不会发生变化，只有根节点分解为2个2-节点时，树的高度才会加一

3.  2-3查找树的与普通的2叉树的最大的区别就是2-3查找树是自底向上生长，可以保持平衡



## 1.2 红黑树

由于2-3查找树的实现较为复杂，于是采用一定的方式对其进行转换得到了红黑树。

红黑树主要是对2-3树进行编码。红黑树的基本思想是利用标准的二叉树和一些额外信息来表示2-3查找树。

红黑树的中链接分为红链接和黑链接：

- 红链接：将两个2-节点连接起来构成一个3-节点

- 黑链接：2-3树中的普通链接

将3-节点表示为由一条左斜的红色链接连接的两个2-节点，这种表示方法的优点在于无需修改就可以使用标准二叉树的get方法



### 红黑树的定义

红黑树是含有红黑链接并满足下列条件的二叉树：

1. 红链接均为左连接

2. 没有任何一个节点同时和两个红链接连接

3. 该树是完美黑平衡的，及任意的空连接到根结点的路径中的黑链接的数量是相同的

### 红黑树的节点接结构

```c++
template<typename K, typename V> 
class Node{
    K key;
    V value;
    Node<K,V>* left;
    Node<K,vV>* right;
    bool color;
}
```

### 平衡化

对红黑树的增删改查可能会破环红黑树的结构，需要对其进行平衡化

#### 左旋

左旋条件：当前节点左子节点为黑色，右子节点为红色

前提条件：当前节点为h，其红色右子节点为x

左旋步骤：

1. 让x的左子节点变为h的右子节点

2. 让h变为x的左子节点

3. x 的color变为h的color

4. h的color变为red

#### 右旋

右旋条件：当前节点的左子节点为红色，且左子节点的左子节点也是红色

前提条件：当前节点为h，其左子节点为x

右旋步骤：

1. 让x的右子节点变成h的左子节点

2. 让h变成x的右子节点

3. 让x的颜色变为h的颜色

4. 让h的颜色边为红色

### 插入

#### 向2-节点中插入新键

比较要插入的键，如果比当前键小，就插入到当前节点的的左子节点，如果需要的话再进行右旋。

如果比当前的键大，就插入到当前节点的右子节点，然后进行左旋，才算完成插入。

#### 颜色反转

当一个节点的左子节点和右子节点同时为红色时，就出现了临时的4-节点，这是需要进行颜色反转，过程就是将两个红色的子节点都变为黑色，将当前节点变为红色。

#### 向3-节点中插入新键

如果新键大于当前的两个键：

1. 将新键插入到当前节点的右子节点处

2. 进行颜色反转

如果新键小于当前的两个键：

1. 就插入到左子节点的左子节点处
2. 右旋
3. 颜色反转

如果新键位于两个键之间

1. 插入左子节点的右子节点处

2. 进行左旋

3. 进行右旋

4. 颜色反转

#### 根节点总是黑色的

因为根节点没有父节点了

### 实现

```c++
bool isRed(Node<K,V>* root){
    if(root==nullptr) return false;
    return root->color == RED;
}
Node<K,V>* rotateLeft(Node<K,V>* root){
    Node<K,V>* x = root->right;
    root->right = x->left;
    x->left = root;
    x->color = root->color;
    root->color = RED;
    return x;
}
Node<K,V>* rotateRight(Node<K,V>* root){
    Node<K,V>* h = root->left;
    root->left = h->right;
    h->right = root;
    h->color = root->color;
    root->color = RED;
    return h;
}
void filpColor(Node<K,V>* root){
    root->left->color = BLACK;
    root->right->color = BLACK;
    root->color = RED;
}
void insert(Node<K,V>* element){
    root = insert_help(root,element);
    root.color = BLACK;
}
Node<K,V>* insert_help(Node<K,V>* root, Node<K,V>* element){
    if(root == nullptr){
        return new Node<K,V>(element);
    }
    if(element->key > root->key){
        root->right = insert(root->right, element);
    }else if(element->key < root->key){
        root->left = insert(root->left,element);
    }else{
        root->val = element->val;
    }
    if(isRead(root->right) && !isRed(root->left)){
        roateLeft(root);
    }
    if(isRed(root->left) && isRed(root->left->left)){
        rotateRight(root);
    }
    if(isRed(root->left) && isRed(root->right)){
        filpColor(root);
    }
    return root;
}
```



## 1.3 B树

### B树的特性

B树中允许一个节点包含多个key，对于一个M阶的B树，它有如下特点：

每个节点最多包含m-1个key，按升序排列

每个节点最多有m个子节点

根节点至少有两个子节点

### B树存储数据

找到该节点可插入的位置

如果找到的节点中已经有m-1个节点了，就插入之后，选取中间元素上升，中间元素两边的元素各自形成新的子节点，称为其父节点的左右子节点

数据插入的过程是自底向上的，也可以保持平衡

### B树在磁盘文件中的应用

B树结构使得磁盘可以快速定位要查找的数据的位置。大大以高了IO效率



## 1.4  B+树

B+树是B树的一种变形，与B树的区别在于：

1. 非叶节点只起一个索引作用，它只存储key，不存储value

2. 所有的叶节点构成一个有序链表，可以按key排序的次序遍历全部数据

存储数据的过程也与B树相似



### B树与B+树的对比

B+树的优点：

1. 因为非叶节点不存储数据，只存储索引，所以在内存相同的情况下，可以存储更多的索引

2. B+树的叶子节点是相连的，所以只需要遍历所有的叶子节点，就可以遍历整个树，而且是有序且相连的，也便于区间查找。对于B树则是需要进行每一层的递归遍历

B树的优点：

由于每个节点都是同时存储着key和value，所以便于获取节点的值。但是B+树要查找一个结点的值，就必须遍历到树的最深处，直到叶节点。



### B+树在数据库中的应用

数据库的索引就采用的B+树结构

便于数据库中的区间查询



# 十、并查集

并查集是一种树形结构，可以高效地完成如下操作：

1. 查询元素p和q是否在同一组
2. 合并元素p和元素q所在的组



##  10.1 并查集结构

并查集对树结构的要求，较为简单：

1. 每个元素都唯一对应一个节点
2. 每一组中的多个元素都在同一棵树中
3. 不同的组形成的树之间没有任何关系
4. 元素在树中没有硬性的子父级关系



## 10.2 并查集的实现

```c++
UnionFind(int n){
    N = n;
    size = n;
    eleGroup = new int[size];
    for(int i=0; i<size; i++){
        eleGroup[i]=i;
    }
}
~UnionFind(){
    delete [] eleGroup;
}
int find(int e){
    if(e<size&&e>=0)
	    return eleGroup[e];
    else
        return -1;
}
bool connected(int p, int q){
    return find(p) == find(q);
}
void Union(int p, int q){
    if(connected(p,q)) return;
    int pg = fiind(p);
    int qg = find(q);
    for(int i=0;i<size;i++){
        if(eleGroup[i]==pg){
            eleGroup[i] = qg;
        }
    }
    N--;
}
```

## 10.3 并查集的应用场景

并查集中的每一个整数代表网络中一个计算机，可以通过connected来检测两个计算机是否相通，如果连通则可以通信，否则可以调用union来使两台计算机连通。

要使所有节点都是连通的，就必须要调用union函数n-1次，而union本身则是O(N)的，那么 经过n-1此调用之后，就变成了O(N^2)



### 10.4 并查集优化

仍然让每个元素的值作为eleGroup的索引；

eleGroup的元素的值是对应的父节点；

对于find方法：

判断当前元素p的父节点eleGroup[p]是不是自己，如果不是就继续找，如果是说明已经到达根节点，就返回结果即可

```c++
int find(int p){
    while(true){
        if(p==eleGroup[p]){
            return p;
        }
        p=eleGroup[p];
    }
}
```

对于union方法

找到p和q的根节点，如果两个根节点是同一个，则无需合并，否则，可以将p的根节点设为q的根节点，分组数量减一

```c++
void Union(int p, int q){
    int proot = find(p);
    int qroot = find(q);
    if(proot == qroot){
        return;
    }
    eleGroup[p] = qroot;
    N--;
}
```





## 10.4 路径压缩

为了尽量减小find方法消耗的时间，应该尽可能保持树的高度尽量低，为了实现这一目标，进行树的合并时，应该将节点数目较小的树合并到节点数目较大的树上

```c++
void union(int p, int q){
    int proot = find(p);
    int qroot = find(q);
    if(proot==qroot) return;
    if(weight[proot]>weight[qroot]){
        eleGroup[qroot] = proot;
        weight[proot] += weight[qroot];
    }else{
        eleGroup[proot] = qroot;
        weight[qroot] += weight[proot];
    }
	N--;
}
```



# 十一、图

## 11.1 图的定义及其分类

定义：一组顶点和一组可以连接它们的边组成的图形

自环：连接同一个顶点的边

平行边：多条连接同一对顶点的边互相称为平行边

分类：无向图和有向图

## 11.2 无向图

### 相关术语

相邻顶点：当两个顶点通过同一条边相邻时，这两个顶点就是相邻的

度：某个顶点的度，就是依赖于这个顶点的边的条数

子图：一幅图所有边的子集及其依赖的顶点组成的图都可以成为是该图的子图

路径：由顺序链接的顶点及连接他们的边组成

环：是一条至少含有一条边，且终点和起点相同的路径

连通图：如果图中任意一个顶点都存在至少一条路径可以到达另一个顶点，就称此图为连通图

连通子图：一个非连通图的连通部分



## 11.3 图的存储结构

要表示一个图，要表述清楚以下两部分即可：

1. 图中的所有顶点
2. 所有连接顶点的边

常见的图的存储结构有两种：邻接矩阵和邻接表（见图论部分）

邻接表的空间复杂度往往低于邻接矩阵



## 11.4 深度优先搜索

如果一个节点既有兄弟节点又有子节点，那么优先查找它的子节点

```c++
bool marked[n];
for(int i=0;i<n;i++){
    marked[i]=false;
}
```



 ## 11.5 广度优先搜索

如果一个节点既有兄弟节点又有子节点，就先搜索兄弟节点在搜索子节点

```c++

```



## 11.6 路径查找





## 11.7 有向图





## 11.8 拓扑排序





## 11.9 加权无向图





## 11.10 最小生成树

贪心算法

prim算法

kruskal算法

## 11.11  加权有向图







## 11.2 最短路径





# 十二、查找算法

## 1. 二分查找

### 原理

在一个有序的序列中，通过比较待查值与待查区域的中值就可以将待查区域缩小为原来的一半，循环此过程直到待查区间只剩下一个值，如果该值还不是待查值，那么该序列中就不存在该待查值。

### 时间复杂度

O(logN)

### 实现

#### 1. 不存在重复元素

```c++
int size = array.size();
int left = 0;
int right = size-1;
int check = c;
while(left<=right){
    int middle = left + (right - left) / 2;
    if(array[middle] < check){
        left = right+1;
    }else if(array[middle] > check){
        right = left -1;
    }else{
        return middle;
    }
}
return -1;
```



#### 2.  查找重复元素中的第一个

```c++
int size = array.size();
int left = 0;
int right = size-1;
int check = c;
while(left<=right){
    int middle = left + (right - left) / 2;
    if(array[middle] < check){
        left = right+1;
    }else if(array[middle] > check){
        right = left -1;
    }else{
        if(middle==0 || array[middle-1] != check){
            return middle;
        }else{
            right = middle-1;
        }
    }
}
return -1;
```

#### 3. 查找重复元素中的最后一个

```c++
int size = array.size();
int left = 0;
int right = size-1;
int check = c;
while(left<=right){
    int middle = left + (right - left) / 2;
    if(array[middle] < check){
        left = right+1;
    }else if(array[middle] > check){
        right = left -1;
    }else{
        if(middle==size-1 || array[middle+1] != check){
            return middle;
        }else{
            left = middle+1;
        }
    }
}
return -1;
```

#### 4. 查找第一个大于等于给定值的元素

```c++
int size = array.size();
int left = 0;
int right = size-1;
int check = c;
while(left<=right){
    int middle = left + (right - left) / 2;
    if(array[middle] < check){
        left = right+1;
    }else{
        if(middle==0 || array[middle-1] < check){
            return middle;
        }else{
            right = middle-1;
        }
    }
}
return -1;
```

#### 5. 查找最后一个小于等于给定值的元素

```c++
int size = array.size();
int left = 0;
int right = size-1;
int check = c;
while(left<=right){
    int middle = left + (right - left) / 2;
    if(array[middle] <= check){
        if(middle==size-1 || array[middle+1]>check){
            return middle;
        }else{
            left = middle+1;
        }
    }else{
        right = middle-1;
    }
}
return -1;
```

### 应用条件

1. 待查询的序列必须是有序的

2. 数据依赖于数组

3. 数据量不可以太大或者太小，因为数据量太小没有必要，如果数据量太大，就会需要很大的连续内存空间。



## 2. 散列表（hash表）

### 概念

散列表是一种根据key直接访问在内存存储位置的数据结构，由数组演化而来，利用了数组支持按下表进行随机访问的特性。键通过散列函数转换为数组的下标，在对应的下标位置上存储信息。

### 散列函数

#### 散列函数的要求

1. 散列函数计算的结果必须是一个大于等于零的正整数，因为hash值会作为数组的下标使用

2. 如果key1等于key2，那么hash(key1)也要等于hash(key2)
3. 如果key1不等于key2，那么hash(key1)也不能等于hash(key2)

#### 散列函数的特点

1. 散列函数不能太复杂，否则会花费过多的时间在计算哈希值上，从而影响散列表的性能
2. 散列函数计算出的哈希值尽可能随机均匀分布，从而尽可能减少散列冲突

#### 散列函数的设计方法

1. 直接寻址法
2. 除留余数法
3. 平房取中法

### 散列冲突

两个不同的关键字由于hash值相同而被映射到同一个位置上，这种线现象被叫做散列冲突或者hash碰撞

#### 解决方案

1. 开放寻址，一旦出现了散列冲突，就去重新寻找一个空的散列地址
   1. 线性探测
   2. 二次检测
   3. 双重散列
2. 链表法，适合大数据量，也支持很多优化策略，比如用红黑树代替链表



### 散列表的应用

HashMap

### 散列算法

如MD5、SHA

## 3. 字符串匹配

### 概念

1. 模式匹配：即子字符串在主字符串中的定位运算，也就串匹配

2. 主字符串：返回的索引所在的字符串，记作T（target）

3. 模式串：其中的子串就是模式串，记作P（parttern）

其中主字符串的长度大于子字符串，主串长度记作n，字串长度记作m

### BF算法

BF算法即Brute Force算法，也叫做暴风算法，是一种蛮力搜索的算法

#### 原理

在主串的位置0、1、...n-m处，检查包括当前字符往后的m个字符，看它是否与模式串相匹配；如果匹配就返回对应的位置，如果找不到相匹配的字串，就返回-1

#### 性能

O(m*n)

#### 实现

```c++
int bf(string p, string t){
    int psize = p.size();
    int tsize = t.size();
    for(int i=0; i<tsize-psize; i++){
        int j=0;
        while(j<psize && p.at(j) == t.at(i+j)){
            j++;
        }
        if(j==psize){
            return j;
        }
    }
    return -1;
}
```

### RK算法

#### 原理

使用hash函数，计算出模式串的hash值，再依次计算出主串中从位置零开始长度为m的字串的hash值，然后找到与模式串的hash值相同的hash值，再进行验证，如果通过验证，那么该hash值对应的位置就是要返回的结果

#### 实现

```c++
bool match(string t, string p, int s){
    int tsize = t.size();
    int psize = p.size();
    if(pszie < tsize+s) return false;
    for(int i=0; i<tszie; i++){
        if(t.at(i) != p.at(s+i))
            return false;
    }
    return true;
}
int hash(string s, int r, int k, int start, int len){
    int hash = 0;
    for(int i=start; i<start+len; i++){
        hash = (hash*R + s.at(i)%k);
    }
    return hash%k;
}
int rk(string p, string t){
    int phash = hash(p,26,31,0,p.size());
    for(int i=0; i<t.size(); i++){
        if(hash(t,26,31,i,p.size())==hash && match(p,t,i){
            return i;
        }
    }
    return -1;
}
```

### BM算法



### KMP算法



# 十三、重要算法思想

## 1. 贪心思想

使用条件：

1. 局部最优策略可以导致产生全局最优解

基本思路：

1. 建立数学模型来描述问题
2. 把求解的问题分成若干个子问题
3. 对每一个子问题求解，得到子问题的局部最优解
4. 把子问题的局部最优解合成原来问题的一个解

举例：

1. 背包问题

2. 钱币找零问题

3. 区间问题

## 2. 分治思想

分治是一种处理问题的思想，递归是一种编程技巧

基本步骤：

1. 分解：将原问题分为规模较小、相互独立且与原问题形式相同的子问题
2. 解决：若子问题规模较小而容易被解决时就直接解决，否则就递归地处理每一个子问题
3. 合并：将子问题的解合并为原来问题的解

使用场景：

1. 原问题与分解成的小问题具有相同的模式
2. 原问题分解成的子问题可以独立求解，子问题之间是相互独立的，这是与动态规划的明显区别之一
3. 具有分解终止的条件，也就是当子问题足够小时可以直接解决
4. 将子问题合并成原问题时的复杂度不可以太高

应用举例：

1. 排序-归并排序、快速排序
2. 海量数据处理

## 3. 动态规划

核心思想：

1. 记住已经解决过的问题的解

记住解的方式：

1. 自顶向下的备忘录

2. 自底向上

应用场景：

1. 具有最优子结构性质的问题，就是可以通过子问题的最优解导出问题的最优解
2. 无后效性，推导后面的状态时，只关心前面的值，不关心值是如何推导出来的，某个阶段的状态一旦确定就不受后面阶段的影响
3. 具有重叠子问题的问题，子问题之间不是独立的

应用举例：

1. 斐波那契数列
2. 最短路径

典型模型：

1. 线性模型
2. 区间模型
3. 背包模型

## 4. 回溯思想

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标，但当探索到某一步时，发现原来的选择并不是最优的，就退回一步重新选择，这种走不通就退回重走的方式称为回溯法。

应用场景：

1. 深度优先搜索
2. 八皇后
3. 0-1背包



# 十四、NP问题







  



























































































































































